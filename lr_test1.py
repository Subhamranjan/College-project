# -*- coding: utf-8 -*-
"""LR_test1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1tESQMw0tW8fiVzDa0XHMc9EasBU26cDK
"""

# Importing necessary libraries
import pandas as pd
import numpy as np
import sklearn
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.metrics import accuracy_score, confusion_matrix, classification_report
from sklearn.preprocessing import StandardScaler
import matplotlib.pyplot as plt

# Load the dataset
dataset = pd.read_csv('/content/drive/MyDrive/datasets/synthetic_flood_prediction_dataset.csv')

# Display the first few rows of the dataset
print("Dataset preview:")
print(dataset.head())

# Checking for missing values
print("\nMissing values in the dataset:")
print(dataset.isnull().sum())

# Fill or drop missing values as necessary
# For example, filling missing values with mean or drop rows
dataset = dataset.dropna()  # Or you can fill missing values using fillna().

# Check column names
print("Column names before stripping:")
print(dataset.columns)

# Strip whitespace from column names
dataset.columns = dataset.columns.str.strip()

# Check column names after stripping
print("Column names after stripping:")
print(dataset.columns)

# Now, proceed to select features (X) and target (y) again
X = dataset[['Rainfall (mm)', 'Temperature (°C)', 'Humidity (%)',
              'River Discharge (m³/s)', 'Water Level (m)',
              'Elevation (m)', 'Historical Floods']]
y = dataset['Flood Occurred']  # Should work now


# Features (X) and Target (y) selection
# X includes Rainfall, Temperature, Humidity, River Discharge, Water Level, and Elevation
# y is the target that indicates flood occurrence (assuming there's a binary label in the data: 0 = No Flood, 1 = Flood)
X = dataset[['Rainfall (mm)', 'Temperature (°C)', 'Humidity (%)', 'River Discharge (m³/s)', 'Water Level (m)', 'Elevation (m)', 'Historical Floods']]
y = dataset['Flood Occurred']  # Assuming 'Flood Occurred' is the column indicating flood occurrence

# Splitting the dataset into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Feature scaling (optional but recommended for regression)
scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train)
X_test_scaled = scaler.transform(X_test)

# Initialize the Linear Regression model
model = LinearRegression()

# Train the model
model.fit(X_train_scaled, y_train)

# Test the model
y_pred = model.predict(X_test_scaled)

# Predict on the training set
y_train_pred = model.predict(X_train_scaled)

# Since Linear Regression returns continuous values, we need to convert them into binary (0 or 1) for classification
# Applying a threshold to determine if flood occurs (you can experiment with different thresholds)
threshold = 0.5  # You can adjust this based on the dataset and results
y_train_pred_class = [1 if pred >= threshold else 0 for pred in y_train_pred]  # Use y_train_pred instead of a non-defined variable

# Calculate accuracy on the training set
train_accuracy = accuracy_score(y_train, y_train_pred_class)
print(f"Training Data Accuracy: {train_accuracy * 100:.5f}")

# Predict on the test set
y_test_pred = model.predict(X_test_scaled)
y_test_pred_class = [1 if pred >= threshold else 0 for pred in y_test_pred]

# Calculate accuracy on the test set
test_accuracy = accuracy_score(y_test, y_test_pred_class)
print(f"Testing Data Accuracy: {test_accuracy * 100:.5f}")

# Evaluate the model
print("\nModel Evaluation:")
print("Confusion Matrix:")
print(confusion_matrix(y_test, y_test_pred_class))  # Use y_test_pred_class instead of y_train_pred_class
print("\nClassification Report:")
print(classification_report(y_test, y_test_pred_class))  # Use y_test_pred_class instead of y_train_pred_class

# Evaluate the model
print("Training Data Classification Report:")
print(classification_report(y_train, y_train_pred_class))

print("\nTesting Data Classification Report:")
print(classification_report(y_test, y_test_pred_class))


def predict_flood(custom_data):
    # Ensure the columns are named correctly
    column_names = ['Rainfall (mm)', 'Temperature (°C)', 'Humidity (%)', 'River Discharge (m³/s)', 'Water Level (m)', 'Elevation (m)', 'Historical Floods']
    custom_data_df = pd.DataFrame([custom_data], columns=column_names)  # Convert to DataFrame with correct column names
    custom_data_scaled = scaler.transform(custom_data_df)  # Scaling custom data
    prediction = model.predict(custom_data_scaled)

    # Convert prediction to flood occurrence using the specified threshold
    if prediction <= threshold:
        return "Flood is likely to occur."
    else:
        return "No flood expected."

def predict_flood_with_probabilities(input_data, model, scaler, threshold=0.6):
    # Check if input_data has 6 features, if so, add a default value for historical floods
    if len(input_data) == 7:
        input_data.append(1)  # or 0, depending on what you want to set as default
    input_scaled = scaler.transform([input_data])

    # Use the fitted model to predict probabilities
    probabilities = model.predict_proba(input_scaled)[:, 1]  # Probability of flood (1)
    prediction = 'Flood is likely to occur.' if probabilities[0] >= threshold else 'No flood expected.'
    return prediction, probabilities[0]

# Define test cases (including historical floods)
test_cases = [
    [150, 28, 90, 600, 6, 50, 1],  # Heavy Rainfall and High Humidity
    [50, 22, 60, 300, 2, 100, 0],   # Moderate Conditions
    [20, 25, 55, 500, 3, 70, 1],    # Low Rainfall with High River Discharge
    [75, 35, 40, 200, 1, 80, 0],     # Extreme Temperature with Normal Rainfall
    [100, 29, 70, 400, 4, 60, 1]     # Just at the Threshold
]

# Run the test cases
for i, custom_input in enumerate(test_cases, 1):
    result = predict_flood(custom_input)  # Specify the threshold
    print(f"Test Case {i}: Input: {custom_input} => Prediction: {result}")

# Define expanded test cases with Historical Floods
expanded_test_cases = [
    # Heavy Rainfall and High Humidity
    [200, 30, 95, 700, 8, 30, 1],  # Extreme conditions
    [180, 32, 88, 650, 7, 40, 1],  # Very high rainfall and humidity

    # Moderate Conditions
    [60, 25, 65, 350, 3, 90, 0],    # Moderate rainfall with moderate conditions
    [45, 20, 55, 250, 2, 110, 0],   # Lower rainfall, cool temperature

    # Low Rainfall with High River Discharge
    [30, 28, 50, 550, 4, 80, 1],     # Low rainfall but high river discharge
    [10, 26, 60, 500, 3, 70, 0],     # Very low rainfall with high humidity

    # High Temperature Scenarios
    [100, 40, 35, 100, 1, 60, 0],    # High temperature, low rainfall
    [90, 38, 45, 200, 2, 50, 1],      # Very high temperature, moderate conditions

    # Just at the Threshold
    [75, 29, 70, 400, 4, 60, 1],      # Just right for a flood prediction
    [85, 31, 72, 450, 5, 55, 0],      # Slightly more rainfall

    # Extremely Low Conditions
    [5, 20, 30, 100, 1, 120, 0],      # Very low rainfall and temperature
    [0, 22, 25, 50, 1, 130, 1],       # No rainfall at all

    # Mixed Conditions
    [150, 33, 80, 600, 5, 45, 1],     # High rainfall, high temperature
    [70, 24, 65, 300, 2, 80, 0],      # Moderate conditions

    # Edge Cases
    [120, 27, 55, 400, 6, 75, 1],     # High rainfall, low temperature
    [50, 35, 85, 350, 3, 100, 0],     # High temperature, moderate rainfall

    # Unlikely Flood Conditions
    [10, 30, 45, 200, 1, 150, 0],     # Low rainfall, moderate temperature
    [20, 25, 50, 300, 2, 140, 1]      # Very low rainfall, mild temperature
]

# Run the expanded test cases
for i, custom_input in enumerate(expanded_test_cases, 1):
    result = predict_flood(custom_input)  # Specify the threshold
    print(f"Test Case {i}: Input: {custom_input} => Prediction: {result}")

# Optional: Visualizing feature importance (for linear regression, we can visualize the coefficients)
coefficients = model.coef_
features = X.columns

plt.figure(figsize=(10, 6))
plt.barh(features, coefficients)
plt.xlabel('Coefficient Value')
plt.title('Feature Importance in Linear Regression')
plt.show()